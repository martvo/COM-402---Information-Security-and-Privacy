In the code for target 1 can be exploited with a buffer overflow attack. The target program allowes the user to copy the content from a characte pointer into a buffer, the size of this buffer is 240. Since there is no length check on the content the char pointer points to before it is copied into the buffer we can write more than 240 bytes to this buffer.
We will achive this by providing a character pointer to a character array which is 248 bytes long. This works as the srtcpy() function copies data until it reaches a null character, which will be located after the 248th byte in our character array. We write 8 bytes past the buffer because we want to acces the stored EIP/instrucion pointer, which is located the stack starting 4 bytes after the end of the buffer, and make it point back into the buffer where we have our shellcode.
We first fill our charater array with NOP instructions (0x90), then overwrite the bytes on position 195 to 240 with the shellcode and then write the wanted return address in the last 4 bytes, owerwriting the return address allready stored there. Since there is only NOP instructions infront of the shellcode we can point to anywhere in the NOP area for this exploit to work. The way I figured out which return address to use was by using the gdb and looking at where the buffer startes and chosing this address as the addres we want to be written over the old one. The program will then execute NOP instructions until it reaches the shellcode and execute it, opening the root shell.
