The exploit in target 2 is similar to the one in tagert 1, but here we can't overflow the buffer with any amount we want as the program only allows ous to overflow it with one byte. We are allowed to overflow it by one byte as the for loop runs one iteration too many (if checks i <= len, instead of checking i < len). This means that we are able to overwrite the saved frame pointer, which is located right after the buffer and before the return address we overwrote in target 1. 
When the nstrcpy() function ends the saved frame pointer becomes the stack pointer again. Then the stack pointer (ESP) will be incremented by 4 as the frame pointer was popped before returning. Now the program will pop the first 4 bytes on the stack after the ESP as it's expect the instruction pointer (EIP) to be there. So by altering the the saved frame pointer we can alter the stack pointer and make it pop what we want into the EIP. Since we only are able to alter the least significant byte of the saved frame pointer we need to store the value we want to pop into EIP somewhere in the buffer with the same first 6 bytes of the address equel to the address of the stored frame pointer.
To achive this I made a character array with a length of 241 bytes, one byte longer than the buffer of the target. Then I filled it with NOP instructions again, put my shellcode 160 bytes into the array, the address of the start of the target buffer 236 bytes into the array and the wrote '0x70' into the last byte as this is will correspon to the address 4 bytes before the value I want to pop into EIP. The value poped into EIP will point to the start of the buffen and the program will execute the NOP instructins before it reaches the shellcode, executing it and giving me the root shell.
